<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Internals · Stheno.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>Stheno.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href="">Internals</a><ul class="internal"><li><a class="toctext" href="#AbstractGP-1">AbstractGP</a></li><li><a class="toctext" href="#GP-1">GP</a></li><li><a class="toctext" href="#CompositeGP-1">CompositeGP</a></li><li><a class="toctext" href="#GPC-1">GPC</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Internals</a></li></ul><a class="edit-page" href="https://github.com/willtebbutt/Stheno.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Interfaces-1" id="Interfaces-1">Interfaces</a></h1><p>The primary objects in Stheno are <code>AbstractGP</code>s, which represent Gaussian processes. There are two primary concrete subtypes of <code>AbstractGP</code>:</p><ul><li><code>GP</code>: an atomic Gaussian process, whose <code>MeanFunction</code> and <code>Kernel</code> are specified directly.</li><li><code>CompositeGP</code>: a Gaussian process composed of other <code>AbstractGP</code>s, whose properties are determined recursively from the <code>AbstractGP</code>s of which it is composed.</li></ul><p>This documentation provides the information necessary to understand the internals of Stheno, and to extend it with your own custom functionality.</p><h2><a class="nav-anchor" href="#AbstractGP-1" id="AbstractGP-1">AbstractGP</a></h2><p>The <code>AbstractGP</code> interface enables one to compute quantities required when working with Gaussian processes in practice, namely to compute their <code>logpdf</code> and sample from them at particular locations in their domain.</p><table><tbody><tr><th style="text-align: left">Function</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>mean_vector(f, x)</code></td><td style="text-align: left">The mean vector of <code>f</code> at inputs <code>x</code></td></tr><tr><td style="text-align: left"><code>cov(f, x)</code></td><td style="text-align: left">covariance matrix of <code>f</code> at inputs <code>x</code></td></tr><tr><td style="text-align: left"><code>cov(f, x, x′)</code></td><td style="text-align: left">covariance matrix between <code>f</code> at <code>x</code> and <code>x′</code></td></tr><tr><td style="text-align: left"><code>cov(f, f′, x, x′)</code></td><td style="text-align: left">cross-covariance matrix between <code>f</code> at <code>x</code> and <code>f′</code> at <code>x′</code></td></tr></tbody></table><p>It should always hold that <code>cov(f, x) ≈ cov(f, f, x, x)</code>, but in some important cases <code>cov(f, x)</code> will be significantly faster.</p><p><code>GP</code> and <code>CompositGP</code> are concrete subtypes of <code>AbstractGP</code>, and can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/gp.jl">here</a></p><h3><a class="nav-anchor" href="#diag-methods-1" id="diag-methods-1">diag methods</a></h3><p>It is crucial for pseudo-point methods, and for the computation of marginal statistics at a reasonable scale, to be able to compute the diagonal of a given covariance matrix in linear time in the size of its inputs. This in turn necessitates that the diagonal of a given cross-covariance matrix can also be computed efficiently as the evaluation of covariance matrices often rely on the evaluation of cross-covariance matrices. As such, we have the following functions:</p><table><tbody><tr><th style="text-align: left">Function</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>cov_diag(f, x)</code></td><td style="text-align: left"><code>diag(cov(f, x))</code></td></tr><tr><td style="text-align: left"><code>cov_diag(f, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, x, x′))</code></td></tr><tr><td style="text-align: left"><code>cov_diag(f, f′, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, f′, x, x′))</code></td></tr></tbody></table><p>The second and third rows of the table only make sense when <code>length(x) == length(x′)</code> of course.</p><h2><a class="nav-anchor" href="#GP-1" id="GP-1">GP</a></h2><p>A <code>GP</code> is constructed in the following manner:</p><pre><code class="language-julia">GP(m, k, gpc)</code></pre><p>where <code>m</code> is its <code>MeanFunction</code>, <code>k</code> its <code>Kernel</code>. <code>gpc</code> is a <code>GPC</code> object that handles some book-keeping, and will be discussed in more depth later (don't worry it's very straightforward, and only mildly annoying).</p><p>The <code>AbstractGP</code> interface is implemented for <code>GP</code>s via operations on their <code>MeanFunction</code> and <code>Kernel</code>. It is therefore straightforward to extend the range of functionality offered by <code>Stheno.jl</code> by simply implementing a new <code>MeanFunction</code> or <code>Kernel</code> which satisfies their interface, which we detail below.</p><h3><a class="nav-anchor" href="#MeanFunctions-1" id="MeanFunctions-1">MeanFunctions</a></h3><p><code>MeanFunction</code>s are unary functions with <code>Real</code>-valued outputs with a single-method interface. They must implement <code>elementwise</code> (aliased to <code>ew</code> for brevity) with the signature</p><pre><code class="language-julia">ew(m::MyMeanFunction, x::AbstractVector)</code></pre><p>This applies the <code>MeanFunction</code> to each element of <code>x</code>, and should return an <code>AbstractVector{&lt;:Real}</code> of the same length as <code>x</code>. Some example implementations can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/mean_and_kernel/mean.jl">here</a>.</p><p>Note that while <code>MeanFunction</code>s are in principle functions, their interface does not require that we can evaluate <code>m(x[p])</code>, only that the "vectorised" <code>elementwise</code> function be implemented. This is due to the fact that, in practice, we only ever need the result of <code>elementwise</code>.</p><p>There are a couple of methods of <code>GP</code> which are specialised to particular <code>MeanFunction</code>s:</p><pre><code class="language-julia">GP(k, gpc) == GP(ZeroMean(), k, gpc)
GP(c, k, gpc) == GP(ConstMean(c), k, gpc) # c&lt;:Real</code></pre><h3><a class="nav-anchor" href="#Kernels-1" id="Kernels-1">Kernels</a></h3><p>A <code>Kernel</code> is a binary function, returning a <code>Real</code>-valued result. <code>Kernel</code>s are only slightly more complicated than <code>MeanFunction</code>s, having a four-method interface:</p><pre><code class="language-julia"># Binary methods
ew(k::MyKernel, x::AbstractVector, x′::AbstractVector) # "Binary elementwise"
pw(k::MyKernel, x::AbstractVector, x′::AbstractVector) # "Binary pairwise"

# Unary methods
ew(k::MyKernel, x::AbstractVector) # "Unary elementwise"
pw(k::MyKernel, x::AbstractVector) # "Unary pairwise"</code></pre><p>Again, <code>ew === elementwise</code> and <code>pw === pairwise</code>.</p><p>Note that, as with <code>MeanFunction</code>s, the <code>Kernel</code> interface does not require that one can actually evaluate <code>k(x[p], x′[q])</code>, as in practice this functionality is never required.</p><p>We consider each method in turn.</p><ul><li>Binary elementwise: compute <code>k(x[p], x′[p])</code> for <code>p in eachindex(x)</code>. <code>x</code> and <code>x′</code> are assumed to be of the same length. Returns a subtype of <code>AbstractVector{&lt;:Real}</code>, of the same length as <code>x</code> and <code>x′</code>.</li><li>Binary pairwiise: compute <code>k(x[p], x′[q])</code> for <code>p in eachindex(x)</code> and <code>q in eachindex(x′)</code>. <code>x</code> and <code>x′</code> need not be of the same length. Returns a subtype of <code>AbstractMatrix{&lt;:Real}</code> whose size is <code>(length(x), length(x′))</code>.</li><li>Unary elementwise: compute <code>k(x[p], x[p])</code> for <code>p in eachindex(x)</code>. Returns a subtype of <code>AbstractVector{&lt;:Real}</code> of the same length as <code>x</code>.</li><li>Unary pairwise: compute <code>k(x[p], x[q])</code> for <code>p in eachindex(x)</code> and <code>q in eachindex(x)</code>. Returns a subtype of <code>AbstractMatrix{&lt;:Real}</code> whose size is <code>(length(x), length(x))</code>. Crucially, output must be positive definite and (approximately) symmetric.</li></ul><p>Example implementations can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/mean_and_kernel/kernel.jl">here</a>. Often you'll find that multiple versions of each method are implemented, specialised to different input types. For example the <code>EQ</code> kernel has (at the time of writing) two implementations of each method, one for inputs <code>AbstractVector{&lt;:Real}</code>, and one for <code>ColsAreObs &lt;: AbstractVector</code> inputs. These specialisations are for performance purposes.</p><h2><a class="nav-anchor" href="#CompositeGP-1" id="CompositeGP-1">CompositeGP</a></h2><p><code>CompositeGP</code>s are constructed as affine transformations of <code>CompositeGP</code>s and <code>GP</code>s. We describe implemented transformations below.</p><h3><a class="nav-anchor" href="#addition-1" id="addition-1">addition</a></h3><p>Given <code>AbstractGP</code>s <code>f</code> and <code>g</code>, we define</p><pre><code class="language-julia">h = f + g</code></pre><p>to be the <code>CompositeGP</code> sastisfying <code>h(x) = f(x) + g(x)</code> for all <code>x</code>. </p><h3><a class="nav-anchor" href="#multiplication-1" id="multiplication-1">multiplication</a></h3><p>Multiplication of <code>AbstractGP</code>s is undefined since the product of two Gaussian random variables is not itself Gaussian. However, we can scale an <code>AbstractGP</code> by either a constant or (deterministic) function.</p><pre><code class="language-julia">h = c * f
h = sin * f</code></pre><p>will both work, and produce the result that <code>h(x) = c * f(x)</code> or <code>h(x) = sin(x) * f(x)</code>.    </p><h3><a class="nav-anchor" href="#composition-1" id="composition-1">composition</a></h3><pre><code class="language-julia">h = f ∘ g</code></pre><p>for some deterministic function <code>g</code> is the composition of <code>f</code> with <code>g</code>. i.e. <code>h(x) = f(g(x))</code>.</p><h3><a class="nav-anchor" href="#conditioning-1" id="conditioning-1">conditioning</a></h3><pre><code class="language-julia">h = g | (f(x) ← y)</code></pre><p>should be read as <code>h</code> is the posterior process produced by conditioning the process <code>g</code> on having observed <code>f</code> at inputs <code>x</code> to take values <code>y</code>.</p><h3><a class="nav-anchor" href="#approximate-conditioning-1" id="approximate-conditioning-1">approximate conditioning</a></h3><p>TODO (implemented, not documented)</p><h3><a class="nav-anchor" href="#cross-1" id="cross-1">cross</a></h3><p>TODO (implemented, not documented)</p><h2><a class="nav-anchor" href="#GPC-1" id="GPC-1">GPC</a></h2><p>This book-keeping object doesn't matter from a user's perspective but, unfortunately, we currently expose it to users. Fortunately, it's very simple to work with. Say you wish to construct a collection of processes:</p><pre><code class="language-julia"># THIS WON'T WORK
f = GP(mf, kf)
g = GP(mg, kg)
h = f + g
# THIS WON'T WORK</code></pre><p>You should actually write</p><pre><code class="language-julia"># THIS IS GOOD. PLEASE DO THIS
gpc = GPC()
f = GP(mf, kf, gpc)
g = GP(mg, kg, gpc)
h = f + g
# THIS IS GOOD. PLEASE DO THIS</code></pre><p>The rule is simple: when constructing <code>GP</code> objects that you plan to make interact later in your programme, construct them using the same <code>gpc</code> object. For example, DON'T do the following:</p><pre><code class="language-julia"># THIS IS BAD. PLEASE DON'T DO THIS
f = GP(mf, kf, GPC())
g = GP(mg, kg, GPC())
h = f + g
# THIS IS BAD. PLEASE DON'T DO THIS</code></pre><p>The mistake here is to construct a separate <code>GPC</code> object for each <code>GP</code>. This will hopefully error, but might yield incorrect results.</p><p>Alternatively, if you're willing to place your model in a function you can write something like:</p><pre><code class="language-julia">@model function foo(some arguments)
    f1 = GP(mean, kernel)
    f2 = GP(some other mean, some other kernel)
    return f1, f2
end</code></pre><p>The <code>@model</code> macro just places a <code>GPC</code> on the first line of the function and provides it as an argument to each <code>GP</code> constructed. Suggestions for ways to improve / extend this interface are greatly appreciated.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></HTML>