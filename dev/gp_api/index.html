<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GP API · Stheno.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Stheno.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li class="current"><a class="toctext" href>GP API</a><ul class="internal"><li><a class="toctext" href="#GP-1">GP</a></li><li><a class="toctext" href="#FiniteGP-1">FiniteGP</a></li><li><a class="toctext" href="#Kernels-1">Kernels</a></li><li><a class="toctext" href="#Transformations-of-Kernels-1">Transformations of Kernels</a></li><li><a class="toctext" href="#Kernel-Convenience-1">Kernel Convenience</a></li><li><a class="toctext" href="#MeanFunctions-1">MeanFunctions</a></li></ul></li><li><a class="toctext" href="../composite_gp_api/">CompositeGP API</a></li><li><a class="toctext" href="../input_types/">Input Types</a></li><li><a class="toctext" href="../kernel_design/">Kernel Design</a></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>GP API</a></li></ul><a class="edit-page" href="https://github.com/willtebbutt/Stheno.jl/blob/master/docs/src/gp_api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>GP API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="GP-API-1" href="#GP-API-1">GP API</a></h1><p>This documents the user-facing API as it relates to the <code>GP</code> object.</p><p>This is a more thorough introduction to the internals than the Getting Started guide, which should be refered to if you are new to Stheno.jl. It&#39;s somewhere between a reference document and a tutorial.</p><h2><a class="nav-anchor" id="GP-1" href="#GP-1">GP</a></h2><p>The primitive <code>GP</code> type is one of the core components of Stheno.jl. A <code>GP</code> should be thought of as a distribution over real-valued functions, in the same way that a <code>Distributions.Normal</code> is a distribution over real numbers, and <code>Distibutions.MvNormal</code> is a distribution over real-valued vectors.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.GP" href="#Stheno.GP"><code>Stheno.GP</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GP{Tm&lt;:MeanFunction, Tk&lt;:Kernel}</code></pre><p>A Gaussian Process (GP) with known mean <code>m</code> and kernel <code>k</code>. A book-keeping object <code>gpc</code> is also required, but only matters when composing <code>GP</code>s together.</p><p><strong>Zero Mean</strong></p><p>If only two arguments are provided, assume the mean to be zero everywhere:</p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern32(), GPC());

julia&gt; x = randn(5);

julia&gt; mean(f(x)) == zeros(5)
true

julia&gt; cov(f(x)) == Stheno.pw(Matern32(), x)
true</code></pre><p><strong>Constant Mean</strong></p><p>If a <code>Real</code> is provided as the first argument, assume the mean function is constant with that value</p><pre><code class="language-julia-repl">julia&gt; f = GP(5.0, EQ(), GPC());

julia&gt; x = randn(5);

julia&gt; mean(f(x)) == 5.0 .* ones(5)
true

julia&gt; cov(f(x)) == Stheno.pw(EQ(), x)
true</code></pre><p><strong>Custom Mean</strong></p><p>Provide an arbitrary function to compute the mean:</p><pre><code class="language-julia-repl">julia&gt; f = GP(x -&gt; sin(x) + cos(x / 2), RQ(3.2), GPC());

julia&gt; x = randn(5);

julia&gt; mean(f(x)) == sin.(x) .+ cos.(x ./ 2)
true

julia&gt; cov(f(x)) == Stheno.pw(RQ(3.2), x)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/gp.jl#L3-L55">source</a></section><h2><a class="nav-anchor" id="FiniteGP-1" href="#FiniteGP-1">FiniteGP</a></h2><p>Once constructed, the correct way to interact with a <code>GP</code> is via a <code>FiniteGP</code>, which is just the multivariate Normal given by considering the <code>GP</code> at only a finite set of inputs.</p><pre><code class="language-julia">f = GP(Matern52(), GPC())
x = randn(10)
fx = f(x)</code></pre><p>here <code>fx</code>, to be read as &quot;f at x&quot;, is a <code>FiniteGP</code> to which the following methods apply:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.mean-Tuple{Stheno.FiniteGP}" href="#Statistics.mean-Tuple{Stheno.FiniteGP}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mean(fx::FiniteGP)</code></pre><p>Compute the mean vector of <code>fx</code>.</p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern52(), GPC());

julia&gt; x = randn(11);

julia&gt; mean(f(x)) == zeros(11)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/abstract_gp.jl#L40-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.cov-Tuple{Stheno.FiniteGP}" href="#Statistics.cov-Tuple{Stheno.FiniteGP}"><code>Statistics.cov</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cov(f::FiniteGP)</code></pre><p>Compute the covariance matrix of <code>fx</code>.</p><p><strong>Noise-free observations</strong></p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern52(), GPC());

julia&gt; x = randn(11);

julia&gt; # Noise-free

julia&gt; cov(f(x)) == Stheno.pw(Matern52(), x)
true</code></pre><p><strong>Isotropic observation noise</strong></p><pre><code class="language-julia-repl">julia&gt; cov(f(x, 0.1)) == Stheno.pw(Matern52(), x) + 0.1 * I
true</code></pre><p><strong>Independent anisotropic observation noise</strong></p><pre><code class="language-julia-repl">julia&gt; s = rand(11);

julia&gt; cov(f(x, s)) == Stheno.pw(Matern52(), x) + Diagonal(s)
true</code></pre><p><strong>Correlated observation noise</strong></p><pre><code class="language-julia-repl">julia&gt; A = randn(11, 11); S = A&#39;A;

julia&gt; cov(f(x, S)) == Stheno.pw(Matern52(), x) + S
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/abstract_gp.jl#L56-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.cov-Tuple{Stheno.FiniteGP,Stheno.FiniteGP}" href="#Statistics.cov-Tuple{Stheno.FiniteGP,Stheno.FiniteGP}"><code>Statistics.cov</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cov(fx::FiniteGP, gx::FiniteGP)</code></pre><p>Compute the cross-covariance matrix between <code>fx</code> and <code>gx</code>.</p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern32(), GPC());

julia&gt; x1 = randn(11);

julia&gt; x2 = randn(13);

julia&gt; cov(f(x1), f(x2)) == pw(Matern32(), x1, x2)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/abstract_gp.jl#L101-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.marginals-Tuple{Stheno.FiniteGP}" href="#Stheno.marginals-Tuple{Stheno.FiniteGP}"><code>Stheno.marginals</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">marginals(f::FiniteGP)</code></pre><p>Compute a vector of Normal distributions representing the marginals of <code>f</code> efficiently. In particular, the off-diagonal elements of <code>cov(f(x))</code> are never computed.</p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern32(), GPC());

julia&gt; x = randn(11);

julia&gt; fs = marginals(f(x));

julia&gt; mean.(fs) == mean(f(x))
true

julia&gt; std.(fs) == sqrt.(diag(cov(f(x))))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/abstract_gp.jl#L119-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG,Stheno.FiniteGP,Int64}" href="#Base.rand-Tuple{Random.AbstractRNG,Stheno.FiniteGP,Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rand(rng::AbstractRNG, f::FiniteGP, N::Int=1)</code></pre><p>Obtain <code>N</code> independent samples from the marginals <code>f</code> using <code>rng</code>. Single-sample methods produce a <code>length(f)</code> vector. Multi-sample methods produce a <code>length(f)</code> x <code>N</code> <code>Matrix</code>.</p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern32(), GPC());

julia&gt; x = randn(11);

julia&gt; rand(f(x)) isa Vector{Float64}
true

julia&gt; rand(MersenneTwister(123456), f(x)) isa Vector{Float64}
true

julia&gt; rand(f(x), 3) isa Matrix{Float64}
true

julia&gt; rand(MersenneTwister(123456), f(x), 3) isa Matrix{Float64}
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/abstract_gp.jl#L141-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.logpdf-Tuple{Stheno.FiniteGP,AbstractArray{#s191,1} where #s191&lt;:Real}" href="#Distributions.logpdf-Tuple{Stheno.FiniteGP,AbstractArray{#s191,1} where #s191&lt;:Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">logpdf(f::FiniteGP, y::AbstractVecOrMat{&lt;:Real})</code></pre><p>The logpdf of <code>y</code> under <code>f</code> if is <code>y isa AbstractVector</code>. logpdf of each column of <code>y</code> if <code>y isa Matrix</code>.</p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern32(), GPC());

julia&gt; x = randn(11);

julia&gt; y = rand(f(x));

julia&gt; logpdf(f(x), y) isa Real
true

julia&gt; Y = rand(f(x), 3);

julia&gt; logpdf(f(x), Y) isa AbstractVector{&lt;:Real}
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/abstract_gp.jl#L173-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.elbo-Tuple{Stheno.FiniteGP,AbstractArray{#s191,1} where #s191&lt;:Real,Stheno.FiniteGP}" href="#Stheno.elbo-Tuple{Stheno.FiniteGP,AbstractArray{#s191,1} where #s191&lt;:Real,Stheno.FiniteGP}"><code>Stheno.elbo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>elbo(f::FiniteGP, y::AbstractVector{&lt;:Real}, u::FiniteGP)</p><p>The saturated Titsias Evidence LOwer Bound (ELBO) [1]. <code>y</code> are observations of <code>f</code>, and <code>u</code> are pseudo-points.</p><pre><code class="language-julia-repl">julia&gt; f = GP(Matern52(), GPC());

julia&gt; x = randn(1000);

julia&gt; z = range(-5.0, 5.0; length=13);

julia&gt; y = rand(f(x, 0.1));

julia&gt; elbo(f(x, 0.1), y, f(z)) &lt; logpdf(f(x, 0.1), y)
true</code></pre><p>[1] - M. K. Titsias. &quot;Variational learning of inducing variables in sparse Gaussian processes&quot;. In: Proceedings of the Twelfth International Conference on Artificial Intelligence and Statistics. 2009.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/abstract_gp.jl#L203-L225">source</a></section><h2><a class="nav-anchor" id="Kernels-1" href="#Kernels-1">Kernels</a></h2><p>This is an ever-growing list. Implementing another kernel would make an excellent first PR...</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.EQ" href="#Stheno.EQ"><code>Stheno.EQ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EQ() &lt;: Kernel</code></pre><p>The standardised Exponentiated Quadratic kernel. a.k.a. the Radial Basis Function (RBF), or Squared Exponential kernel.</p><p><span>$k(x, x^\prime) = \exp( -\frac{1}{2} || x - x^\prime||_2^2 )$</span></p><p>For length scales etc see <a href="@ref"><code>stretch</code></a>, for variance see <a href="#Base.:*-Tuple{Real,Kernel}"><code>*</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L78-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Matern12" href="#Stheno.Matern12"><code>Stheno.Matern12</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Matern12 &lt;: Kernel</code></pre><p>The standardised Matern-1/2 / Exponential kernel:</p><p><span>$k(x, x^\prime) = \exp(-||x - x^\prime||_2)$</span></p><p>For length scales etc see <a href="@ref"><code>stretch</code></a>, for variance see <a href="#Base.:*-Tuple{Real,Kernel}"><code>*</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L126-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Exp" href="#Stheno.Exp"><code>Stheno.Exp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Exp &lt;: Kernel</code></pre><p>The standardised Exponential kernel. Equivalent to <a href="#Stheno.Matern12"><code>Matern12</code></a>.</p><p>For length scales etc see <a href="@ref"><code>stretch</code></a>, for variance see <a href="#Base.:*-Tuple{Real,Kernel}"><code>*</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L147-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Matern32" href="#Stheno.Matern32"><code>Stheno.Matern32</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Matern32 &lt;: Kernel</code></pre><p>The standardised Matern kernel with ν = 3 / 2.</p><p>For length scales etc see <a href="@ref"><code>stretch</code></a>, for variance see <a href="#Base.:*-Tuple{Real,Kernel}"><code>*</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L158-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Matern52" href="#Stheno.Matern52"><code>Stheno.Matern52</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Matern52 &lt;: Kernel</code></pre><p>The standardised Matern kernel with ν = 5 / 2.</p><p>For length scales etc see <a href="@ref"><code>stretch</code></a>, for variance see <a href="#Base.:*-Tuple{Real,Kernel}"><code>*</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L182-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.RQ" href="#Stheno.RQ"><code>Stheno.RQ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RQ &lt;: Kernel</code></pre><p>The standardised Rational Quadratic, with kurtosis <code>α</code>.</p><p>For length scales etc see <a href="@ref"><code>stretch</code></a>, for variance see <a href="#Base.:*-Tuple{Real,Kernel}"><code>*</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L214-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Cosine" href="#Stheno.Cosine"><code>Stheno.Cosine</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Cosine &lt;: Kernel</code></pre><p>Cosine Kernel with period parameter <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L249-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Linear" href="#Stheno.Linear"><code>Stheno.Linear</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Linear{T&lt;:Real} &lt;: Kernel</code></pre><p>The standardised linear kernel / dot-product kernel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L273-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Poly" href="#Stheno.Poly"><code>Stheno.Poly</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Poly{Tσ&lt;:Real} &lt;: Kernel</code></pre><p>Inhomogeneous Polynomial kernel. <code>Poly(p, σ²)</code> creates a <code>Poly{p}</code> with variance σ², defined as</p><pre><code class="language-julia">k(xl, xr) = (dot(xl, xr) + σ²)^p</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L294-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.GammaExp" href="#Stheno.GammaExp"><code>Stheno.GammaExp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GammaExp</code></pre><p>The γ-Exponential kernel, 0 &lt; γ ⩽ 2, is given by <code>k(xl, xr) = exp(-||xl - xr||^γ)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L327-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.Wiener" href="#Stheno.Wiener"><code>Stheno.Wiener</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Wiener &lt;: Kernel</code></pre><p>The standardised stationary Wiener-process kernel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L347-L351">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.WienerVelocity" href="#Stheno.WienerVelocity"><code>Stheno.WienerVelocity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">WienerVelocity &lt;: Kernel</code></pre><p>The standardised WienerVelocity kernel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L366-L370">source</a></section><h2><a class="nav-anchor" id="Transformations-of-Kernels-1" href="#Transformations-of-Kernels-1">Transformations of Kernels</a></h2><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>stretch(::Stheno.Kernel, ::Union{Real, AbstractVecOrMat{&lt;:Real}})</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Real,Kernel}" href="#Base.:*-Tuple{Real,Kernel}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">*(σ²::Real, k::Kernel)
*(k::Kernel, σ²::Real)</code></pre><p>The right way to choose the variance of a kernel. Specifically, construct a kernel that scales the output of <code>k</code> by <code>σ²</code>:</p><pre><code class="language-julia-repl">julia&gt; k = EQ();

julia&gt; x = randn(11);

julia&gt; pw(0.5 * k, x) == 0.5 .* Stheno.pw(k, x)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L520-L534">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Tuple{Kernel,Kernel}" href="#Base.:+-Tuple{Kernel,Kernel}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">+(kl::Kernel, kr::Kernel)</code></pre><p>Construct the kernel whose value is given by the sum of those of <code>kl</code> and <code>kr</code>.</p><pre><code class="language-julia-repl">julia&gt; kl, kr = EQ(), Matern32();

julia&gt; x = randn(11);

julia&gt; pw(kl + kr, x) == pw(kl, x) + pw(kr, x)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L446-L459">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Kernel,Kernel}" href="#Base.:*-Tuple{Kernel,Kernel}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">+(kl::Kernel, kr::Kernel)</code></pre><p>Construct the kernel whose value is given by the product of those of <code>kl</code> and <code>kr</code>.</p><pre><code class="language-julia-repl">julia&gt; kl, kr = EQ(), Matern32();

julia&gt; x = randn(11);

julia&gt; pw(kl * kr, x) == pw(kl, x) .* pw(kr, x)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L482-L495">source</a></section><h2><a class="nav-anchor" id="Kernel-Convenience-1" href="#Kernel-Convenience-1">Kernel Convenience</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Stheno.kernel" href="#Stheno.kernel"><code>Stheno.kernel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">kernel(k::Kernel;  l::Real=nothing, s::Real=nothing)</code></pre><p>Convenience functionality to provide a kernel with a length scale <code>l</code>, and to scale the variance of <code>k</code> by <code>s</code>. Simply applies the <a href="@ref stretch"><code>stretch</code></a> and <a href="#Base.:*-Tuple{Real,Kernel}"><code>*</code></a> functions.</p><pre><code class="language-julia-repl">julia&gt; k1 = kernel(EQ(); l=1.1, s=0.9);

julia&gt; k2 = 0.9 * stretch(EQ(), 1 / 1.1);

julia&gt; x = randn(11);

julia&gt; pw(k1, x) == pw(k2, x)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/willtebbutt/Stheno.jl/blob/0c3921a22fac7ac744f7db33a4a9f712c2f41b36/src/gp/kernel.jl#L678-L695">source</a></section><h2><a class="nav-anchor" id="MeanFunctions-1" href="#MeanFunctions-1">MeanFunctions</a></h2><p>These are implicit. Please refer to the <code>GP</code> documentation for details.</p><footer><hr/><a class="previous" href="../getting_started/"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="../composite_gp_api/"><span class="direction">Next</span><span class="title">CompositeGP API</span></a></footer></article></body></html>
