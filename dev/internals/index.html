<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · Stheno.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Stheno.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../input_types/">Input Types</a></li><li><a class="tocitem" href="../kernel_design/">Kernel Design</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#AtomicGP"><span>AtomicGP</span></a></li><li><a class="tocitem" href="#CompositeGP"><span>CompositeGP</span></a></li><li><a class="tocitem" href="#GPPP"><span>GPPP</span></a></li></ul></li><li><a class="tocitem" href="../examples/custom_affine_transformations/">Custom Affine Transformations</a></li><li><a class="tocitem" href="../api/">API</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_note/">Notes on Examples</a></li><li><a class="tocitem" href="../examples/process_decomposition/">Process Decomposition</a></li><li><a class="tocitem" href="../examples/sensor_fusion/">Sensor Fusion</a></li><li><a class="tocitem" href="../examples/time_varying_blr/">Time-Varying Bayesian Linear Regression</a></li><li><a class="tocitem" href="../examples/gppp_and_pseudo_points/">Pseudo-Points in Additive Regression</a></li><li><a class="tocitem" href="../examples/extended_mauna_loa/">CO2 and temperature</a></li><li><a class="tocitem" href="../examples/naive-linear-mixing/">-</a></li></ul></li><li><span class="tocitem">Experimental Examples</span><ul><li><a class="tocitem" href="../experimental_examples_notes/">Notes on Experimental Examples</a></li><li><a class="tocitem" href="../examples/differentiation/">Differentation</a></li><li><a class="tocitem" href="../examples/quadrature-convolution/">Convolution via Quadrature</a></li><li><a class="tocitem" href="../examples/convolutional_gp/">The Convolutional Gaussian Process</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGaussianProcesses/Stheno.jl/blob/master/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h1><p>The primary objects in Stheno are some special subtypes of <code>AbstractGP</code>. There are three primary concrete subtypes of <code>AbstractGP</code>:</p><ul><li><code>AtomicGP</code>: an atomic Gaussian process given by wrapping an <code>AbstractGP</code>.</li><li><code>CompositeGP</code>: a Gaussian process composed of other <code>AtomicGP</code>s and <code>CompositeGP</code>s, whose properties are determined recursively from the GPs of which it is composed.</li><li><code>GaussianProcessProbabilisticProgramme</code> / <code>GPPP</code>: a Gaussian process comprising <code>AtomicGP</code>s and <code>CompositeGP</code>s. This is the primary piece of functionality that users should interact with.</li></ul><p>Each of these types implements the <a href="https://github.com/JuliaGaussianProcesses/AbstractGPs.jl">Internal AbstractGPs API</a>.</p><p>This documentation provides the information necessary to understand the internals of Stheno, and to extend it with custom functionality.</p><h3 id="diag-methods"><a class="docs-heading-anchor" href="#diag-methods">diag methods</a><a id="diag-methods-1"></a><a class="docs-heading-anchor-permalink" href="#diag-methods" title="Permalink"></a></h3><p>It is crucial for pseudo-point methods, and for the computation of marginal statistics at a reasonable scale, to be able to compute the diagonal of a given covariance matrix in linear time in the size of its inputs. This, in turn, necessitates that the diagonal of a given cross-covariance matrix can also be computed efficiently as the evaluation of covariance matrices often rely on the evaluation of cross-covariance matrices. As such, we have the following functions in addition to the AbstractGPs API implemented for <code>AtomicGP</code>s and <code>CompositeGP</code>s:</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>var(f, x)</code></td><td style="text-align: left"><code>diag(cov(f, x))</code></td></tr><tr><td style="text-align: left"><code>var(f, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, x, x′))</code></td></tr><tr><td style="text-align: left"><code>var(f, f′, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, f′, x, x′))</code></td></tr></table><p>The second and third rows of the table only make sense when <code>length(x) == length(x′)</code>, of course.</p><h2 id="AtomicGP"><a class="docs-heading-anchor" href="#AtomicGP">AtomicGP</a><a id="AtomicGP-1"></a><a class="docs-heading-anchor-permalink" href="#AtomicGP" title="Permalink"></a></h2><p>We can construct a <code>AtomicGP</code> in the following manner:</p><pre><code class="language-julia hljs">f = atomic(GP(m, k), gpc)
</code></pre><p>where <code>m</code> is its <code>MeanFunction</code>, <code>k</code> its <code>Kernel</code>. <code>gpc</code> is a <code>GPC</code> object that handles some book-keeping, and is discussed in more depth below.</p><p>The <code>AbstractGP</code> interface is implemented for <code>AtomicGP</code>s in terms of the <code>AbstractGP</code> that they atomic. So if you want a particular behaviour, just make sure that the <code>AbstractGP</code> that you atomic has the functionality you want.</p><h3 id="Aside:-Example-Kernel-implementation"><a class="docs-heading-anchor" href="#Aside:-Example-Kernel-implementation">Aside: Example Kernel implementation</a><a id="Aside:-Example-Kernel-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Aside:-Example-Kernel-implementation" title="Permalink"></a></h3><p>It&#39;s straightforward to implement a new kernel yourself: simply following the instructions in <a href="https://github.com/JuliaGaussianProcesses/KernelFunctions.jl">KernelFunctions.jl</a> and it&#39;ll work fine with GPs in Stheno.jl.</p><h3 id="GPC"><a class="docs-heading-anchor" href="#GPC">GPC</a><a id="GPC-1"></a><a class="docs-heading-anchor-permalink" href="#GPC" title="Permalink"></a></h3><p>This book-keeping object doesn&#39;t matter from a user&#39;s perspective but, unfortunately, we currently expose it to users. Fortunately, it&#39;s straightforward to work with. Say you wish to construct a collection of processes:</p><pre><code class="language-julia hljs"># THIS WON&#39;T WORK
f = GP(mf, kf)
g = GP(mg, kg)
h = f + g
# THIS WON&#39;T WORK</code></pre><p>You should write</p><pre><code class="language-julia hljs"># THIS IS GOOD. PLEASE DO THIS
gpc = GPC()
f = atomic(GP(mf, kf), gpc)
g = atomic(GP(mg, kg), gpc)
h = f + g
# THIS IS GOOD. PLEASE DO THIS</code></pre><p>The rule is simple: when constructing GPs that you plan to make interact later in your program, construct them using the same <code>gpc</code> object. For example, DON&#39;T do the following:</p><pre><code class="language-julia hljs"># THIS IS BAD. PLEASE DON&#39;T DO THIS
f = atomic(GP(mf, kf), GPC())
g = atomic(GP(mg, kg), GPC())
h = f + g
# THIS IS BAD. PLEASE DON&#39;T DO THIS</code></pre><p>The mistake here is to construct a separate <code>GPC</code> object for each <code>GP</code>. Hopefully, the code errors, but might yield incorrect results.</p><h2 id="CompositeGP"><a class="docs-heading-anchor" href="#CompositeGP">CompositeGP</a><a id="CompositeGP-1"></a><a class="docs-heading-anchor-permalink" href="#CompositeGP" title="Permalink"></a></h2><p><code>CompositeGP</code>s are constructed as affine transformations of <code>CompositeGP</code>s and <code>AtomicGP</code>s. We describe the implemented transformations below. You can add additional transformations – see <a href="../examples/custom_affine_transformations/#Custom-Affine-Transformations">Custom Affine Transformations</a> for an a worked example.</p><h3 id="Addition"><a class="docs-heading-anchor" href="#Addition">Addition</a><a id="Addition-1"></a><a class="docs-heading-anchor-permalink" href="#Addition" title="Permalink"></a></h3><p>Given <code>AbstractGP</code>s <code>f</code> and <code>g</code>, we define</p><pre><code class="language-julia hljs">h = f + g</code></pre><p>to be the <code>CompositeGP</code> sastisfying <code>h(x) = f(x) + g(x)</code> for all <code>x</code>.</p><h3 id="Multiplication"><a class="docs-heading-anchor" href="#Multiplication">Multiplication</a><a id="Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Multiplication" title="Permalink"></a></h3><p>Multiplication of <code>AbstractGP</code>s is undefined since the product of two Gaussian random variables is not itself Gaussian. However, we can scale an <code>AbstractGP</code> by either a constant or (deterministic) function.</p><pre><code class="language-julia hljs">h = c * f
h = sin * f</code></pre><p>will both work, and produce the result that <code>h(x) = c * f(x)</code> or <code>h(x) = sin(x) * f(x)</code>.</p><h3 id="Composition"><a class="docs-heading-anchor" href="#Composition">Composition</a><a id="Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Composition" title="Permalink"></a></h3><pre><code class="language-julia hljs">h = f ∘ g</code></pre><p>for some deterministic function <code>g</code> is the composition of <code>f</code> with <code>g</code>. i.e. <code>h(x) = f(g(x))</code>.</p><h3 id="cross"><a class="docs-heading-anchor" href="#cross">cross</a><a id="cross-1"></a><a class="docs-heading-anchor-permalink" href="#cross" title="Permalink"></a></h3><pre><code class="language-julia hljs">h = cross([f, g])</code></pre><p>for <code>WrappedGPs</code> and <code>CompositeGP</code>s <code>f</code> and <code>g</code>. Think of <code>cross</code> as having stacked <code>f</code> and <code>g</code> together, so that you can work with their joint.</p><p>For example, if you wanted to sample jointly from <code>f</code> and <code>g</code> at locations <code>x_f</code> and <code>x_g</code>, you could write something like</p><pre><code class="language-julia hljs">fg = cross([f, g])
x_fg = BlockData([x_f, x_g])
rand(fg(x_fg, 1e-6))</code></pre><p>This particular function isn&#39;t part of the user-facing API because it isn&#39;t generally needed. It is, however, used extensively in the implementation of the <code>GaussianProcessProbabilisticProgramme</code>.</p><h2 id="GPPP"><a class="docs-heading-anchor" href="#GPPP">GPPP</a><a id="GPPP-1"></a><a class="docs-heading-anchor-permalink" href="#GPPP" title="Permalink"></a></h2><p>The <code>GaussianProcessProbabilisticProgramme</code> is another <code>AbstractGP</code> which enables provides a thin layer of convenience functionality on top of <code>AtomicGP</code>s and <code>CompositeGP</code>s, and is the primary way in which it is intended that users will interact with this package.</p><p>A <code>GPPP</code> like this</p><pre><code class="language-julia hljs">f = @gppp let
    f1 = GP(SEKernel())
    f2 = GP(Matern52Kernel())
    f3 = f1 + f2
end</code></pre><p>is equivalent to manually constructing a <code>GPPP</code> using <code>AtomicGP</code>s and <code>CompositeGP</code>s:</p><pre><code class="language-julia hljs">gpc = GPC()
f1 = atomic(GP(SEKernel()), gpc)
f2 = atomic(GP(SEKernel()), gpc)
f3 = f1 + f2
f = Stheno.GPPP((f1=f1, f2=f2, f3=f3), gpc)</code></pre><p>If you take a look at the <code>gaussian_process_probabilistic_programming.jl</code> source, you&#39;ll see that it&#39;s essentially just the above, and an implementation of the <code>AbstractGP</code>s API on top of a <code>GPPP</code>.</p><p>A <code>GPPP</code> is a single GP on an extended input domain: <img src="../no_luck_catching_them_swans_then.jpeg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../kernel_design/">« Kernel Design</a><a class="docs-footer-nextpage" href="../examples/custom_affine_transformations/">Custom Affine Transformations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Friday 3 June 2022 11:10">Friday 3 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
