<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · Stheno.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Stheno.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Internals</a><ul class="internal"><li><a class="toctext" href="#AbstractGP-1">AbstractGP</a></li><li><a class="toctext" href="#GP-1">GP</a></li><li><a class="toctext" href="#CompositeGP-1">CompositeGP</a></li><li><a class="toctext" href="#GPC-1">GPC</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Internals</a></li></ul><a class="edit-page" href="https://github.com/willtebbutt/Stheno.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Interfaces-1" href="#Interfaces-1">Interfaces</a></h1><p>The primary objects in Stheno are <code>AbstractGP</code>s, which represent Gaussian processes. There are two primary concrete subtypes of <code>AbstractGP</code>:</p><ul><li><code>GP</code>: an atomic Gaussian process, whose <code>MeanFunction</code> and <code>Kernel</code> are specified directly.</li><li><code>CompositeGP</code>: a Gaussian process composed of other <code>AbstractGP</code>s, whose properties are determined recursively from the <code>AbstractGP</code>s of which it is composed.</li></ul><p>This documentation provides the information necessary to understand the internals of Stheno, and to extend it with your own custom functionality.</p><h2><a class="nav-anchor" id="AbstractGP-1" href="#AbstractGP-1">AbstractGP</a></h2><p>The <code>AbstractGP</code> interface enables one to compute quantities required when working with Gaussian processes in practice, namely to compute their <code>logpdf</code> and sample from them at particular locations in their domain.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>mean_vector(f, x)</code></td><td style="text-align: left">The mean vector of <code>f</code> at inputs <code>x</code></td></tr><tr><td style="text-align: left"><code>cov(f, x)</code></td><td style="text-align: left">covariance matrix of <code>f</code> at inputs <code>x</code></td></tr><tr><td style="text-align: left"><code>cov(f, x, x′)</code></td><td style="text-align: left">covariance matrix between <code>f</code> at <code>x</code> and <code>x′</code></td></tr><tr><td style="text-align: left"><code>cov(f, f′, x, x′)</code></td><td style="text-align: left">cross-covariance matrix between <code>f</code> at <code>x</code> and <code>f′</code> at <code>x′</code></td></tr></table><p>It should always hold that <code>cov(f, x) ≈ cov(f, f, x, x)</code>, but in some important cases <code>cov(f, x)</code> will be significantly faster.</p><p><code>GP</code> and <code>CompositeGP</code> are concrete subtypes of <code>AbstractGP</code>, and can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/gp.jl">here</a> and <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/composite/composite_gp.jl">here</a> respectively.</p><h3><a class="nav-anchor" id="diag-methods-1" href="#diag-methods-1">diag methods</a></h3><p>It is crucial for pseudo-point methods, and for the computation of marginal statistics at a reasonable scale, to be able to compute the diagonal of a given covariance matrix in linear time in the size of its inputs. This in turn necessitates that the diagonal of a given cross-covariance matrix can also be computed efficiently as the evaluation of covariance matrices often rely on the evaluation of cross-covariance matrices. As such, we have the following functions:</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>cov_diag(f, x)</code></td><td style="text-align: left"><code>diag(cov(f, x))</code></td></tr><tr><td style="text-align: left"><code>cov_diag(f, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, x, x′))</code></td></tr><tr><td style="text-align: left"><code>cov_diag(f, f′, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, f′, x, x′))</code></td></tr></table><p>The second and third rows of the table only make sense when <code>length(x) == length(x′)</code> of course.</p><h2><a class="nav-anchor" id="GP-1" href="#GP-1">GP</a></h2><p>A <code>GP</code> is constructed in the following manner:</p><pre><code class="language-julia">GP(m, k, gpc)</code></pre><p>where <code>m</code> is its <code>MeanFunction</code>, <code>k</code> its <code>Kernel</code>. <code>gpc</code> is a <code>GPC</code> object that handles some book-keeping, and will be discussed in more depth later (don&#39;t worry it&#39;s very straightforward, and only mildly annoying).</p><p>The <code>AbstractGP</code> interface is implemented for <code>GP</code>s via operations on their <code>MeanFunction</code> and <code>Kernel</code>. It is therefore straightforward to extend the range of functionality offered by <code>Stheno.jl</code> by simply implementing a new <code>MeanFunction</code> or <code>Kernel</code> which satisfies their interface, which we detail below.</p><h3><a class="nav-anchor" id="MeanFunctions-1" href="#MeanFunctions-1">MeanFunctions</a></h3><p><code>MeanFunction</code>s are unary functions with <code>Real</code>-valued outputs with a single-method interface. They must implement <code>elementwise</code> (aliased to <code>ew</code> for brevity) with the signature</p><pre><code class="language-julia">ew(m::MyMeanFunction, x::AbstractVector)</code></pre><p>This applies the <code>MeanFunction</code> to each element of <code>x</code>, and should return an <code>AbstractVector{&lt;:Real}</code> of the same length as <code>x</code>. Some example implementations can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/mean.jl">here</a>.</p><p>Note that while <code>MeanFunction</code>s are in principle functions, their interface does not require that we can evaluate <code>m(x[p])</code>, only that the &quot;vectorised&quot; <code>elementwise</code> function be implemented. This is due to the fact that, in practice, we only ever need the result of <code>elementwise</code>.</p><p>There are a couple of methods of <code>GP</code> which are specialised to particular <code>MeanFunction</code>s:</p><pre><code class="language-julia">GP(k::Kernel, gpc::GPC) == GP(ZeroMean(), k, gpc)
GP(c::Real, k::Kernel, gpc::GPC) == GP(ConstMean(c), k, gpc)</code></pre><h3><a class="nav-anchor" id="Kernels-1" href="#Kernels-1">Kernels</a></h3><p>A <code>Kernel</code> is a binary function, returning a <code>Real</code>-valued result. <code>Kernel</code>s are only slightly more complicated than <code>MeanFunction</code>s, having a four-method interface:</p><pre><code class="language-julia"># Binary methods
ew(k::MyKernel, x::AbstractVector, x′::AbstractVector) # &quot;Binary elementwise&quot;
pw(k::MyKernel, x::AbstractVector, x′::AbstractVector) # &quot;Binary pairwise&quot;

# Unary methods
ew(k::MyKernel, x::AbstractVector) # &quot;Unary elementwise&quot;
pw(k::MyKernel, x::AbstractVector) # &quot;Unary pairwise&quot;</code></pre><p>Again, <code>ew === elementwise</code> and <code>pw === pairwise</code>.</p><p>Note that, as with <code>MeanFunction</code>s, the <code>Kernel</code> interface does not require that one can actually evaluate <code>k(x[p], x′[q])</code>, as in practice this functionality is never <em>really</em> required and would otherwise be extra code to maintain.</p><p>We consider each method in turn.</p><ul><li>Binary elementwise: compute <code>k(x[p], x′[p])</code> for <code>p in eachindex(x)</code>. <code>x</code> and <code>x′</code> are assumed to be of the same length. Returns a subtype of <code>AbstractVector{&lt;:Real}</code>, of the same length as <code>x</code> and <code>x′</code>.</li><li>Binary pairwise: compute <code>k(x[p], x′[q])</code> for <code>p in eachindex(x)</code> and <code>q in eachindex(x′)</code>. <code>x</code> and <code>x′</code> need not be of the same length. Returns a subtype of <code>AbstractMatrix{&lt;:Real}</code> whose size is <code>(length(x), length(x′))</code>.</li><li>Unary elementwise: compute <code>k(x[p], x[p])</code> for <code>p in eachindex(x)</code>. Returns a subtype of <code>AbstractVector{&lt;:Real}</code> of the same length as <code>x</code>.</li><li>Unary pairwise: compute <code>k(x[p], x[q])</code> for <code>p in eachindex(x)</code> and <code>q in eachindex(x)</code>. Returns a subtype of <code>AbstractMatrix{&lt;:Real}</code> whose size is <code>(length(x), length(x))</code>. Crucially, output must be positive definite and (approximately) symmetric.</li></ul><p>Example implementations can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/mean_and_kernel/kernel.jl">here</a>. Often you&#39;ll find that multiple versions of each method are implemented, specialised to different input types. For example the <code>EQ</code> kernel has (at the time of writing) two implementations of each method, one for inputs <code>AbstractVector{&lt;:Real}</code>, and one for <code>ColsAreObs &lt;: AbstractVector</code> inputs. These specialisations are for performance purposes.</p><h3><a class="nav-anchor" id="Example-Kernel-implementation-1" href="#Example-Kernel-implementation-1">Example Kernel implementation</a></h3><p>It&#39;s straightforward to implement a new kernel yourself: just define a new type and implement the two <code>pw</code> and <code>ew</code> methods required to make it play nicely with everything else in Stheno. This process is broken down below.</p><pre><code class="language-julia">using Stheno
using Stheno: Kernel

struct EQ{Tl&lt;:Real} &lt;: Kernel
    l::Tl
end

_eq(l::Real, xl::Real, xr::Real) = exp(-((xl - xr) / l)^2)</code></pre><p>The above just defines a structure that represents an Exponentiated Quadratic (a.k.a. RBF / Radial Basis Function, Squared Exponential) kernel with length scale <code>l</code>. The <code>_eq</code> function defines how the kernel operates on a pair of real values given the length-scale, and is just a helper function used to define the <code>pw</code> and <code>ew</code> methods below.</p><pre><code class="language-julia">import Stheno: pw
pw(k::EQ, x::AbstractVector{&lt;:Real}) = _eq.(k.l, x, x&#39;)</code></pre><p>This is one way to implement the unary <code>pairwise</code> method for this kernel using Julia&#39;s broadcasting functionality. Sampling from the prior and computing the log marginal probability of data are possible given just this method:</p><pre><code class="language-julia"># Construct a GP. See below for info regarding the GPC, but don&#39;t worry
# too much about it.
using Stheno: GPC
l = 2.4
f = GP(EQ(l), GPC())

# Sample from the prior and add some iid observation noise with variance 0.1.
x = range(-5.0, 5.0; length=100)
y = rand(f(x, 0.1))

# Compute the log marginal probability of `y`.
logpdf(f(x, 0.1), y)</code></pre><p>To compute posterior predictive likelihoods, and to sample from the posterior, the binary <code>pairwise</code> method is required:</p><pre><code class="language-julia"># Define binary `pairwise` method.
pw(k::EQ, xl::AbstractVector{&lt;:Real}, xr::AbstractVector{&lt;:Real}) = _eq.(k.l, xl, xr&#39;)

# Compute posterior process.
f_post = f | (f(x, 0.1) ← y);

# Sample from posterior predictive with a tiny amount of noise for numerical stability.
x_pr = randn(10)
y_pr = rand(f_post(x_pr, 1e-12))

# Compute the log marginal conditional probability of the posterior sample.
logpdf(f_post(x_pr, 1e-12), y_pr)</code></pre><p>Often the marginal statistics of a GP are helpful, and it is for these (and pseudo-point methods) that the <code>elementwise</code> / <code>ew</code> methods are required:</p><pre><code class="language-julia">import Stheno: ew
ew(k::EQ, xl::AbstractVector{&lt;:Real}, xr::AbstractVector{&lt;:Real}) = _eq.(k.l, xl, xr)
ew(k::EQ, x::AbstractVector{&lt;:Real}) = ones(length(x))</code></pre><p>It is now possible to compute the posterior marginal statistics at a large number of points efficiently:</p><pre><code class="language-julia">f_post_marginals = marginals(f_post(range(-10.0, 10.0; length=5_000)))
means = mean.(f_post_marginals)
stds = std.(f_post_marginals)</code></pre><p>and to use Stheno&#39;s plotting functionality for pretty-printing:</p><pre><code class="language-julia">using Plots # Possibly type `]add Plots`
plot(f_post(range(-10.0, 10.0; length=2_000)); samples=10, color=:blue, label=&quot;&quot;)
scatter!(x, y; markersize=2.0, color=:black, label=&quot;&quot;)</code></pre><p>Stheno provides a more general implementation of the Exponentiated Quadratic (EQ) kernel, which is only a minor extension of the above, and can be found in <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/kernel.jl">kernels.jl</a> alongside various other kernels that are available.</p><h3><a class="nav-anchor" id="Why-no-sensible-fallbacks?-1" href="#Why-no-sensible-fallbacks?-1">Why no sensible fallbacks?</a></h3><p>Early versions of Stheno required that new kernels also define a method that simply evaluates the kernel at a pair of inputs (i.e. the functionality provided by the <code>_eq</code> function in the example above). This requirement was found to be of minimal use in practice in any situation other than prototyping as, in the vast majority of cases, better performance is obtained by directly implementing <code>pw</code> and <code>ew</code>. This difference in performance is often sufficiently stark as to render them useless for most practical purposes, meaning that it usually better for Stheno to error and let the user know that an efficient method is missing than to proceed with the fallback.</p><p>If you feel this approach is helpful for your work, it is recommended to adapt the code developed in the example above, and simply define a function similar to <code>_ew</code> that suits your own needs. Alternatively, if you would <em>really</em> to see this functionality, please raise an issue or open a PR. As with most things in the Julia ecosystem, it will get built if there is sufficient demand.</p><h3><a class="nav-anchor" id="AbstractGP-Interface-Implementation-1" href="#AbstractGP-Interface-Implementation-1">AbstractGP Interface Implementation</a></h3><p>Given the above, the <code>AbstractGP</code> interface is straightforward to implement for <code>GPs</code>, as each method of <code>mean_vector</code> and <code>cov</code> can be implemented in terms of <code>ew</code> and <code>pw</code>. See <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/gp.jl">here</a> for the implementation.</p><p>If you are interested just in working with a single <code>GP</code> object, with a known <code>MeanFunction</code> and <code>Kernel</code>, this is probably as far as you need to go. Simply implement you own fancy <code>Mean</code> and <code>Kernel</code> objects, or approximations to them, and have some fun / do some research.</p><h2><a class="nav-anchor" id="CompositeGP-1" href="#CompositeGP-1">CompositeGP</a></h2><p><code>CompositeGP</code>s are constructed as affine transformations of <code>CompositeGP</code>s and <code>GP</code>s. We describe implemented transformations below.</p><h3><a class="nav-anchor" id="addition-1" href="#addition-1">addition</a></h3><p>Given <code>AbstractGP</code>s <code>f</code> and <code>g</code>, we define</p><pre><code class="language-julia">h = f + g</code></pre><p>to be the <code>CompositeGP</code> sastisfying <code>h(x) = f(x) + g(x)</code> for all <code>x</code>. </p><h3><a class="nav-anchor" id="multiplication-1" href="#multiplication-1">multiplication</a></h3><p>Multiplication of <code>AbstractGP</code>s is undefined since the product of two Gaussian random variables is not itself Gaussian. However, we can scale an <code>AbstractGP</code> by either a constant or (deterministic) function.</p><pre><code class="language-julia">h = c * f
h = sin * f</code></pre><p>will both work, and produce the result that <code>h(x) = c * f(x)</code> or <code>h(x) = sin(x) * f(x)</code>.    </p><h3><a class="nav-anchor" id="composition-1" href="#composition-1">composition</a></h3><pre><code class="language-julia">h = f ∘ g</code></pre><p>for some deterministic function <code>g</code> is the composition of <code>f</code> with <code>g</code>. i.e. <code>h(x) = f(g(x))</code>.</p><h3><a class="nav-anchor" id="conditioning-1" href="#conditioning-1">conditioning</a></h3><pre><code class="language-julia">h = g | (f(x) ← y)</code></pre><p>should be read as <code>h</code> is the posterior process produced by conditioning the process <code>g</code> on having observed <code>f</code> at inputs <code>x</code> to take values <code>y</code>.</p><h3><a class="nav-anchor" id="approximate-conditioning-1" href="#approximate-conditioning-1">approximate conditioning</a></h3><p>TODO (implemented, not documented)</p><h3><a class="nav-anchor" id="cross-1" href="#cross-1">cross</a></h3><p>TODO (implemented, not documented)</p><h2><a class="nav-anchor" id="GPC-1" href="#GPC-1">GPC</a></h2><p>This book-keeping object doesn&#39;t matter from a user&#39;s perspective but, unfortunately, we currently expose it to users. Fortunately, it&#39;s very simple to work with. Say you wish to construct a collection of processes:</p><pre><code class="language-julia"># THIS WON&#39;T WORK
f = GP(mf, kf)
g = GP(mg, kg)
h = f + g
# THIS WON&#39;T WORK</code></pre><p>You should actually write</p><pre><code class="language-julia"># THIS IS GOOD. PLEASE DO THIS
gpc = GPC()
f = GP(mf, kf, gpc)
g = GP(mg, kg, gpc)
h = f + g
# THIS IS GOOD. PLEASE DO THIS</code></pre><p>The rule is simple: when constructing <code>GP</code> objects that you plan to make interact later in your programme, construct them using the same <code>gpc</code> object. For example, DON&#39;T do the following:</p><pre><code class="language-julia"># THIS IS BAD. PLEASE DON&#39;T DO THIS
f = GP(mf, kf, GPC())
g = GP(mg, kg, GPC())
h = f + g
# THIS IS BAD. PLEASE DON&#39;T DO THIS</code></pre><p>The mistake here is to construct a separate <code>GPC</code> object for each <code>GP</code>. This will hopefully error, but might yield incorrect results.</p><p>Alternatively, if you&#39;re willing to place your model in a function you can write something like:</p><pre><code class="language-julia">@model function foo(some arguments)
    f1 = GP(mean, kernel)
    f2 = GP(some other mean, some other kernel)
    return f1, f2
end</code></pre><p>The <code>@model</code> macro just places a <code>GPC</code> on the first line of the function and provides it as an argument to each <code>GP</code> constructed. Suggestions for ways to improve / extend this interface are greatly appreciated.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
