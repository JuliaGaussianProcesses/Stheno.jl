<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Input Types · Stheno.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Stheno.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li><a class="toctext" href="../gp_api/">GP API</a></li><li><a class="toctext" href="../composite_gp_api/">CompositeGP API</a></li><li class="current"><a class="toctext" href>Input Types</a><ul class="internal"><li><a class="toctext" href="#The-Central-Assumption-1">The Central Assumption</a></li><li><a class="toctext" href="#Dimensional-Euclidean-Space-1">1-Dimensional Euclidean Space</a></li><li><a class="toctext" href="#D-Dimensional-Euclidean-Space-1">D-Dimensional Euclidean Space</a></li><li><a class="toctext" href="#Worked-Example-1">Worked Example</a></li></ul></li><li><a class="toctext" href="../kernel_design/">Kernel Design</a></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Input Types</a></li></ul><a class="edit-page" href="https://github.com/willtebbutt/Stheno.jl/blob/master/docs/src/input_types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Input Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Input-Types-1" href="#Input-Types-1">Input Types</a></h1><p>Stheno enables the user to handle any type of input domain they wish and provides a common API that users must implement when considering a new way of representing input data to ensure that the package knows how to handle them appropriately.</p><p>Discussed below is this interface&#39;s core assumptions, a detailed account of a couple of important concrete input types. Additionally, we provide a worked-example of a new input type.</p><h2><a class="nav-anchor" id="The-Central-Assumption-1" href="#The-Central-Assumption-1">The Central Assumption</a></h2><p>The central assumption made in all user-facing and internal functions is this: <strong>when a collection of inputs are required, they subtype <code>AbstractVector</code></strong>. For example, <code>x isa AbstractVector</code> when indexing into a GP:</p><pre><code class="language-julia">f(x, σ²)</code></pre><p>or computing the covariance matrix associated with a kernel:</p><pre><code class="language-julia">pw(EQ(), x)</code></pre><p>When computing the cross-covariance matrix between two GPs</p><pre><code class="language-julia">cov(f, g, x_f, x_g)</code></pre><p><code>x_f</code> and <code>x_g</code> must be <code>AbstractVector</code>s. <em>All other operations involving collections of inputs have the same restrictions</em>. Always <code>AbstractVector</code>s.</p><p>For example, this means that when handling multi-dimensional inputs stored in a <code>Matrix</code> they must be wrapped so that the package knows to treat them as a vector — more on this in below in <em>D-dimensional Euclidean Spaces</em>.</p><h2><a class="nav-anchor" id="Dimensional-Euclidean-Space-1" href="#Dimensional-Euclidean-Space-1">1-Dimensional Euclidean Space</a></h2><p>When constructing a GP whose domain is the real-line, for example when using a GP to solve some kind of time-series problem, it is sufficient to work with <code>Vector{&lt;:Real}</code>s of inputs. As such, the following is completely valid:</p><pre><code class="language-julia">using Stheno: GPC
f = GP(EQ(), GPC())
x = randn(10)
f(x)</code></pre><p>It is also possible to work with other <code>AbstractArray</code>s that represent a vector of 1-dimensional points, e.g.</p><pre><code class="language-julia">x = range(-5.0, 5.0; length=100)
f(x)</code></pre><h2><a class="nav-anchor" id="D-Dimensional-Euclidean-Space-1" href="#D-Dimensional-Euclidean-Space-1">D-Dimensional Euclidean Space</a></h2><p>Many applications of interest involve more than a single input-dimension, such as spatio-temporal modeling or Machine Learning tasks. For these cases, we provide <code>ColVecs &lt;: AbstractVector</code>.</p><pre><code class="language-julia">X_data = randn(5, 100)
X = ColVecs(X_data)</code></pre><p>tells Stheno that it should treat each column of <code>X_data</code> as a vector-valued input. Phrased differently, <code>X</code> is an <code>AbstractVector{T}</code> where <code>T &lt;: Vector{&lt;:Real}</code>, which stores its elements in memory as a dense matrix. This approach has the advantage of making it completely explicit how Stheno treats a matrix of data, and also simplifies quite a bit of the internal machinery, as all vectors of inputs can be assumed to be a subtype of <code>AbstractVector</code>.</p><p>Future plans include a <code>RowVecs</code> type, which would instead treat each row of <code>X_data</code> as a vector-valued input. If you would like this feature, please raise an issue or a PR to let us know there&#39;s a demand for it. The worked example below actually makes some headway on this, so it provides an excellent starting point for a PR!</p><h3><a class="nav-anchor" id="Structure-in-D-Dimensional-Euclidean-Space-1" href="#Structure-in-D-Dimensional-Euclidean-Space-1">Structure in D-Dimensional Euclidean Space</a></h3><p>Consider a rectilinear grid of points in D-dimensional Euclidean space. Such grids of points can be represented in a more memory-efficient manner than can arbitrarily locate sets of points. Moreover, this structure can be exploited to accelerate inference for certain types of problems dramatically. Other such examples exist e.g., uniform grids in N-dimensions, and can be exploited to more efficiently represent input data and to accelerate inference.</p><p>Work to exploit these kinds of structures is on-going at the time of writing and will be documented before merging.</p><h2><a class="nav-anchor" id="Worked-Example-1" href="#Worked-Example-1">Worked Example</a></h2><p>As discussed, <code>ColVecs</code> is already supported for inputs in D-dimensional Euclidean space, where <code>Matrix</code> stores a collection of inputs, and each <strong>column</strong> is an input. The following example presents <code>RowVecs</code>, which represents collections inputs residing in D-dimensional Euclidean space, but the interpretation is different: each <strong>row</strong> of the matrix corresponds to an input.</p><p>Firstly, the new data structure is specified:</p><pre><code class="language-julia">struct RowVecs{T&lt;:Real} &lt;: AbstractVector{Vector{T}}
    X::Matrix{T}
end</code></pre><p>Observe that it subtypes <code>AbstractVector</code>, and each element is a <code>Vector{T&lt;:Real}</code>. It has a single field <code>X</code>, which is a matrix of elements. It is necessary to implement some parts of the <a href="https://docs.julialang.org/en/v1/manual/interfaces/index.html#man-interface-array-1">AbstractArray interface</a> to ensure printing and various consistency checks inside the package work as intended:</p><pre><code class="language-julia">Base.length(x::RowVecs) = size(x.X, 1)
Base.size(x::RowVecs) = (length(x),)
Base.getindex(x::RowVecs, n::Int) = x.X[n, :]</code></pre><p>This structure prints nicely and pass some consistency checks, but none of the base <code>Kernel</code>s in the package know how to treat it. This means that, for example, new <code>pw</code> and <code>ew</code> methods that are specialised to <code>RowVec</code> must be added:</p><pre><code class="language-julia">import Stheno: pw
using Distances: SqEuclidean
pw(k::EQ, x::RowVecs, x′::RowVecs) = exp.(.-pw(SqEuclidean(), x.X, x′.X; dims=1) ./ 2)
# insert implementations for the unary pw and the two ew methods</code></pre><p>In the worst case, this means that every <code>Kernel</code> needs four new methods to handle a new data structure. Fortunately, this case isn&#39;t typical. Most of the <code>Kernel</code>s in <code>src/kernels.jl</code> are implemented in terms of the <code>SqEuclidean</code> and <code>Euclidean</code> distances, and are generically typed. As such it is sufficient to add new <code>ew</code> and <code>pw</code> methods involving those types, without the need to re-implement those methods for kernels. See <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/util/distances.jl">src/util/distances.jl</a> for examples.</p><footer><hr/><a class="previous" href="../composite_gp_api/"><span class="direction">Previous</span><span class="title">CompositeGP API</span></a><a class="next" href="../kernel_design/"><span class="direction">Next</span><span class="title">Kernel Design</span></a></footer></article></body></html>
